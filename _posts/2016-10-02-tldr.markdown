---
layout: post
title:  "Minimal Definitions (tl;dr version)" 
date:   2016-10-03 11:00:00
category: thoughts
author: Jentery Sayers 
---

I've been researching the various uses and implications of "minimal computing." What does it mean? According to whom? For whom? Under what assumptions? Yesterday, I wrote a rather unpolished [thought piece on the topic](http://go-dh.github.io/mincomp/thoughts/2016/10/02/minimal-definitions/), but below is the tl;dr version of my observations.  

Minimal computing appears to prompt these fundamental questions about choice and necessity: "What do we need?" (see [Gil](http://go-dh.github.io/mincomp/thoughts/2015/05/21/user-vs-learner/)) "What don't we need?" "What do we want?" "What don't we want?"

The brief definitions below point to some interesting overlaps and tensions between the multiple aims (stated or not) of minimal computing. For now, tho, I'm listing them here without synthesis, analysis, or any assumption that the list is complete. Soon, I'll add some questions that may emerge from each definition. Feedback is welcome in the meantime. Thank you! 

## Minimal Design

Reduce the need to update/modify the structure or layout of a project in order to focus on content production and to increase the likelihood of project persistence

## Minimalist Design  

Reduce the use of features to highlight a project's fundamental components across platforms/devices

## Minimal WYSIWYG 

Reduce the use of What You See Is What You Get (WYSIWYG) interfaces to decrease resource demands, increase awareness of programming and markup processes, and also increase individual focus on writing 

## Minimal Dependencies 

Reduce reliance on scripts, databases, libraries, versions, and software to decrease resource demands and processing time 

## Minimal Maintenance

Reduce dependencies and the use of features to decrease the labor of updating, moderating, and stewarding a project over time 

## Maximum Ephemerality 

Reduce an impulse to inscribe, measure, or visualize with technologies in order to increase the likelihood of experimentation and collective participation 

## Minimal Use 

Reduce the use of natural resources and technologies (especially hardware, middleware, and peripherals) to decrease environmental effects and energy consumption 

## Minimal Consumption 

Reduce arguments premised on technological progress, the early adoption/implementation of technologies, and the treatment of computing as work (to create products) in order to increase deliberation, thoroughness of research, and the likelihood of informed decisions  

## Minimal Obsolescence 

Reduce turnover of technologies, standards, and formats to increase reuse and decrease waste/discards 

## Minimal Presence

Reduce the use of laptops, desktops, and other computers in order to prototype with low-tech materials (clay, paper, pencils), decrease reliance on automation, and increase comparative studies (across digital and analog media)

## Minimal Visibility 

Reduce the perceived intervention of technologies to facilitate interaction as well as the production/extraction of data from those interactions/behaviors (Internet of Things) 

## Maximum Access

Reduce the use of proprietary technologies and paywalls to increase access to content, data, and/or source files 

## Maximum Accessibility 

Through shared guidelines and frequent user testing, reduce the use of features that are difficult to see, read, hear, translate, use, navigate, process, store, or find toward access by everyone and to also increase the overall quality and consistency of projects 

## Maximum Justice 

Reduce the use of technological, cultural, social, and economic barriers to increase entry, access, participation, and self-representation in computing and to also build systems/projects premised on social justice and difference, not white supremacy and settler colonialism

## Minimal Learning Curve

Reduce the experience assumed or required to participate in computing and technological work 

## Maximum Negotiation 

Reduce the rigidity of form, composition, and use to increase the personalization, adaptability, responsiveness, and/or robustness of technologies 

## Minimal Internet 

Reduce reliance on the internet for communication, exchange, and participation to account for or privilege local conditions 

## Minimal Surveillance 

Reduce the use of sensors, computer vision, cookies, and other tracking mechanisms to increase privacy and security and to decrease harassment and hacks 

## Minimal Vulnerabilities 

Reduce attack vectors (e.g., cross-site scripting, SQL injections, and directory traversals) of projects to decrease likelihood of hacks and harassment 

## Minimal Externals

Reduce dependency on external groups or mechanisms to produce, exchange, and circulate your own projects and content 

## Minimal Automation 

Reduce use of mechanisms that (magically) turn input into output in order to increase awareness of how this becomes that or how algorithms/tools make decisions 

## Minimal Space 

Reduce the physical space dedicated to hardware and workstations to increase the flexible use, variability, and modularity of that space 

## Maximum Mobility 

Reduce dependency on fixed technologies (e.g., desktops plugged into walls) to increase movement, performance, and participation across events and settings  

## Minimal Technical Language 

Reduce the use of specialized language to increase participation and engagement with shared technocultural problems 
